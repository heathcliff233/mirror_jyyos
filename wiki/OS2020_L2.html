<html>
  <Head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    
<link rel="stylesheet" href="../static/css/bootstrap.min.css"/>
<link rel="stylesheet" href="../static/css/bootstrap-theme.min.css"/>


    <link rel="stylesheet" href="../static/css/fonts/crmison.css"/>
    <link rel="stylesheet" href="../static/css/fonts/fira_code.css"/>
    <link rel="stylesheet" href="../static/css/fonts/ptsans.css"/>
    <link rel="stylesheet" href="../static/css/katex.min.css"/>
    <link rel="stylesheet" href="../static/css/wiki.css"/>
    <link rel="stylesheet" href="../static/css/codehilite.css"/>

    <script src="../static/js/jquery.min.js"></script>
    <script src="../static/js/bootstrap.bundle.min.js"></script>
    <script src="../static/js/katex.min.js"></script>
    
    

    <title>L2: 多处理器内核上的线程管理 (kmt)</title>
  </Head>
  <body>
   
   
<nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-barnd" href="index.html">Yanyan's Wiki</a>
  <div class="collapse navbar-collapse">
    <div class="navbar-nav">
      <a class="nav-item nav-link active" href="OS2020.html">
        <img class="textimg" src="../static/wiki/logo-n.png"/>
        操作系统 (2020)</a>
      <a class="nav-item nav-link active" href="SysLab2020.html">
        计算机系统综合实验 (2020)</a>
      <a class="nav-item nav-link active" href="ICS_NJU.html"><img class="textimg" height="18px" src="../static/img/ics.png"/> 加入我们</a>
    </div>
    <form class="form-inline" autocomplete="off">
      <input id="token-input" type="text" oninput="login();" maxlength="16"
        data-toggle="tooltip" data-placement="bottom"
        title="用于确定身份的作业提交 SHA-1 hash digest。更改后回车或刷新网页生效"></input>
    </form>
  </div>
</nav>

<center>
  <div class="article-container">
    <div class="article">
      <h1 id="l2-kmt">L2: 多处理器内核上的线程管理 (kmt)</h1>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">官方测试用例已发布。</h4>
<h4 id="online-judge">Online Judge 暂未发布。</h4>
</div></div></div>

<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">截止日期</h4>
<p>关于实验环境设置、提交方法、评分规则等，请阅读<a href="OS2020_Labs.html">实验须知</a>。获取代码，在 <code>os-workbench</code> 中执行：</p>
<pre class="codehilite"><code>git pull origin L2</code></pre>


<ul>
<li>如果你合并时发生了冲突，说明你修改了 <code>framework/</code> 下的代码。作为代价，请 STFW 如何解决 git pull 时的冲突。如果你对你的操作不自信，操作之前记得备份你的 <code>os-workbench</code> 目录，这个目录包含了你所有的 git 记录。</li>
</ul>
<p>Soft Deadline: 2020 年 5 月 3 日 23:59:59。</p>
<p>本实验在 L1 代码的基础上完成。但如果你完全没有完成 L1，依然可以合并代码并开始 L2 (例如使用一个非常简单的 kalloc/kfree 实现)。需要提交以学号命名的 .pdf 格式实验报告 (保存在 <code>kernel/</code> 目录下，在 L1 的实验报告之后添加)。除非特殊情况，本次实验报告新增内容<strong>不建议超过 2 页 A4 纸</strong>。请在实验报告中描述你在实验中遇到的特别值得一提的事件，例如你代码的架构设计、特别精巧的实现、遇到印象深刻的 bug 等。</p>
</div></div></div>

<div plugin="submission(course='OS2020', module='L2')"><div class="accordion submission" id="accordionExample">

  <div class="card">
    <div class="card-header submit-card">
      <form action="../upload.html" method="post" enctype="multipart/form-data">
        <div class="form-row align-items-center">
            <label class="col-form-label">OS2020-L2</label> 提交结果
        </div>
      </form>
    </div>
  </div>



</div></div>

<div markdown="1"><div class="fenced fenced-green"><div>
<h4 id="_1">热身问题：理解操作系统</h4>
<p>我们的课堂上也演示过几份短小的代码，这将是大家操作系统实验的 “骨架”：</p>
<ul>
<li><a href="../static/wiki/os/2020/demos/thread-os.c">thread-os.c</a>: 一个分时调度固定数量线程、round-robin调度的嵌入式操作系统；</li>
<li><a href="../static/wiki/os/2020/demos/thread-os-mp.c">thread-os-mp.c</a>: 把刚才的代码扩展到多处理器；</li>
<li><a href="../static/wiki/os/2020/demos/trivial-os.c">trivial-os.c</a>: 真正的多处理器多进程操作系统，不过每个进程只允许拥有一个页面；代码、数据、堆栈都必须位于这个页面中。当然，这已经 “无限” 接近一个真正的操作系统了。</li>
</ul>
<p>从这个实验开始，我们要实现 “丰富版” 的 trivial-os.c——一个实现了经典计算机系统机制的操作系统。上面的代码都是 AbstractMachine 上实现的 “操作系统”，可以说是大家完成实验最好的参考，请务必花一些时间阅读/理解/调试。</p>
</div></div></div>

<h2 id="1">1. 背景</h2>
<p>之前的两个实验 (L0, L1) 已经为大家熟悉在 bare-metal 上编程铺好了路。借助 AbstractMachine 提供的机制 (C Runtime、物理内存、中断/异常等)，我们可以很容易地实现 CPU 的虚拟化，和进程/线程的模拟。在确保你对 “操作系统” 有了概念上的认识以后，我们就可以真正开始实现操作系统中的 “虚拟化” 部分了。现在，我们已经知道这是由 “中断机制” 实现的，在进程/线程执行时中断到来，操作系统代码开始执行并保存处理器运行的寄存器现场；在中断返回时，可以选择任何一个进程/线程已经保存的寄存器现场恢复，从而实现上下文切换。Abstract Machine 也提供了这个机制 (由 CTE API 提供)。</p>
<p>在这个实验中，我们实现多处理器操作系统内核中的内核线程 API (就像 pthreads 库，或是课堂上展示的 <code>threads.h</code>)。在完成这个实验后，你已经得到了一个真正的嵌入式操作系统 (加强版的 <code>thread-os-mp.c</code>)。</p>
<h2 id="2">2. 实验描述</h2>
<h3 id="21">2.1 实验总览</h3>
<p>这个实验在 pmm 的基础上，进一步实现内核线程相关的操作系统内核 API：</p>
<ul>
<li>相比 Lab1, os 模块中新增了 <code>trap</code> 和 <code>on_irq</code> 两个函数，分别是系统中唯一中断/系统调用的入口和中断处理程序的回调注册；</li>
<li>pmm 模块保持不变，你可以沿用 Lab1 的实现，但因为这个实验中多了中断，你需要对你已有的代码做一些小改；</li>
<li>新增了 kmt 模块，你需要完成 <code>struct task</code>, <code>struct spinlock</code>, <code>struct semaphore</code> 的定义并实现其中全部的 API。</li>
</ul>
<div markdown="1"><div class="fenced fenced-blue"><div>
<h4 id="_1">不用定义结构体也能编译通过？</h4>
<p>没错。只要我们不引用 <code>struct task</code> 的任何成员，我们在代码中使用 <code>struct task</code> (或它的别名 <code>task_t</code>) 就不会引起问题。例如，为函数传递 <code>struct task *</code> 的指针是没问题的。但因为你需要实现具体操作这些结构体的函数，因此你需要定义它们。</p>
<p>你可以把你们的定义放在 <code>include/</code> 目录下的某个头文件里。</p>
</div></div></div>

<pre class="codehilite"><code class="language-c">typedef _Context *(*handler_t)(_Event, _Context *);
MODULE(os) {
  void (*init)();
  void (*run)();
  _Context *(*trap)(_Event ev, _Context *context);
  void (*on_irq)(int seq, int event, handler_t handler);
};

MODULE(pmm) {
  void  (*init)();
  void *(*alloc)(size_t size);
  void  (*free)(void *ptr);
};

typedef struct task task_t;
typedef struct spinlock spinlock_t;
typedef struct semaphore sem_t;
MODULE(kmt) {
  void (*init)();
  int  (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);
  void (*teardown)(task_t *task);
  void (*spin_init)(spinlock_t *lk, const char *name);
  void (*spin_lock)(spinlock_t *lk);
  void (*spin_unlock)(spinlock_t *lk);
  void (*sem_init)(sem_t *sem, const char *name, int value);
  void (*sem_wait)(sem_t *sem);
  void (*sem_signal)(sem_t *sem);
};</code></pre>


<h3 id="22-os-operating-systems">2.2 OS (Operating Systems) 模块</h3>
<h4 id="221">2.2.1 操作系统的主循环</h4>
<p>os 模块是操作系统主循环的代码，主要负责系统的初始化和中断响应。我们在上一个实验的框架代码中，已经包含了以下函数：</p>
<ul>
<li><code>os-&gt;init()</code> 会在系统启动时被启动的第一个处理器调用 (仅初始化一次)，它在单处理器状态下完成必要的初始化——因此你不用担心数据竞争等麻烦；</li>
<li><code>os-&gt;run()</code> 是操作系统启动后每个处理器必须执行的一些代码。我们假设 <code>os-&gt;run()</code> 时已经完成了所有初始化工作，每个处理器都会调用同一份 <code>os-&gt;run</code>。</li>
</ul>
<p>你可能会修改你已有的实现，例如你现在的 <code>os-&gt;init()</code> 看起来可能长这样：</p>
<pre class="codehilite"><code class="language-c">static void os_init() {
  pmm-&gt;init();
}</code></pre>


<p>但你可能会在其中增加 kmt 模块的初始化：</p>
<pre class="codehilite"><code class="language-c">static void os_init() {
  pmm-&gt;init();
  kmt-&gt;init();
}</code></pre>


<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="os-gtrun"><code>os-&gt;run()</code> 的行为改变</h4>
<p>与上个实验不同，我们<strong>会</strong>调用你的 <code>os-&gt;run()</code>。因此如果你有任何测试代码 (如创建一些用户线程的 <code>kmt-&gt;create</code>)，可以考虑以下两种方法：</p>
<ol>
<li>(不推荐) 写在 <code>main</code> 函数中，Online Judge 会使用另一份 framework，所以你插入的所有测试代码都不会被执行。</li>
<li>(推荐) 写在 <code>os-&gt;init</code> 中，但使用一些预编译指令确保在 Online Judge 时测试代码不会被执行 (启动一个 “空的” 操作系统)。</li>
</ol>
</div></div></div>

<p>理解 os 模块，要从程序执行的入口开始，以下是框架代码执行的流程：</p>
<pre class="codehilite"><code class="language-c">int main() {
  _ioe_init();
  _cte_init(os-&gt;trap);
   os-&gt;init();
  _mpe_init(os-&gt;run);
  return 1;
}</code></pre>


<p>在每个处理器调用 <code>os-&gt;run</code> 执行 (并最终被中断) 后，操作系统就化身成为了中断处理程序。调用 <code>_mpe_init()</code> 之后，所有的处理器都开始执行 <code>os-&gt;run()</code>，操作系统正式启动，而启动代码就成为了当前处理器上的第一个线程——这个线程是这个处理器上的 “idle” 线程：当系统中没有线程可以被调度的时候，我们的处理器也必须执行点什么，直到下一次中断到来，因此它可以是一个死循环：</p>
<pre class="codehilite"><code class="language-c">static void os_run() {
  _intr_write(1);
  while (1);
}</code></pre>


<p>主循环的另一部分是本次实验新增的中断处理程序的入口</p>
<ul>
<li><code>os-&gt;trap(ev, context)</code>: 中断/异常处理程序的唯一入口。中断后，AbstractMachine 会将所有寄存器保存到堆栈上 (就像 xv6 那样)，然后调用 <code>os-&gt;trap()</code>，并且在函数返回后，将 <code>os-&gt;trap()</code> 返回的寄存器现场恢复到 CPU 上。</li>
</ul>
<p>直到 <code>_mpe_init()</code> 之前，都只有一个处理器在执行 (编号为 0 的 CPU，此时调用 <code>_cpu()</code> 会返回 <code>0</code>)。在上面的代码中，<code>_cte_init(os-&gt;trap)</code> 指定了<code>os-&gt;trap</code> 是唯一的中断处理程序，所有的处理器发生中断都会统一调用 <code>os-&gt;trap()</code>。在中断的时候做什么完全是由你决定的。</p>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">小心多处理器中断</h4>
<p>因为每个处理器都会被中断，这让 <code>os-&gt;trap()</code> 变成了被并行执行的代码。因此，如果里面有任何共享变量，你需要用自旋锁保护好 (并且要小心死锁，并小心地管理中断标志位)，消灭数据竞争——还记得 “可见性” 的例子吗？</p>
</div></div></div>

<h4 id="222">2.2.2 中断处理程序</h4>
<p>os 模块的另一个重要功能是管理系统中的中断处理程序——我们并不希望大家在每当有一个新的功能以后，都直接去改 <code>os-&gt;trap</code> 的代码，因此我们提供了另一个 API:</p>
<ul>
<li><code>os-&gt;on_irq(seq, event, handler)</code>: 注册一个在中断时调用的 callback。</li>
</ul>
<p><code>on_irq</code> 的含义是在 <code>os-&gt;trap(ev, ctx)</code> 执行时，当 <code>ev.event</code> (事件编号) 和 <code>event</code> 匹配时，调用 <code>handler(event, ctx);</code>。其中：</p>
<ul>
<li><code>seq</code> 决定了 handler 被调用的顺序，<code>seq</code> 小的 handler 先被调用。<code>seq</code> 相同的按任意顺序调用；</li>
<li>当 <code>event == _EVENT_NULL</code> 时，在任何中断/异常时都调用 <code>handler</code>；</li>
<li>我们允许一个且仅一个 handler 返回一个 <code>_Context</code>，在中断返回时恢复到这个 conetxt。当多个 handler 都返回 context 时，是 undefined behavior。</li>
</ul>
<p>如果我们看 xv6 的代码 (<code>trap.c</code>)，我们会看到中断到来时的 if-else 结构：</p>
<pre class="codehilite"><code class="language-c">  if(tf-&gt;trapno == T_SYSCALL){
    ...
  }
  switch(tf-&gt;trapno){
  case T_IRQ0 + IRQ_TIMER:
    ...
  case T_IRQ0 + IRQ_IDE:
    ...
  }</code></pre>


<p>我们用 <code>on_irq</code> 机制实现了上述代码的灵活控制: os 模块现在变得非常简单，它甚至完全不需要知道其他任何模块的存在。在参考代码中，<code>os-&gt;trap()</code> 的实现类似于：</p>
<pre class="codehilite"><code class="language-c++">static _Context *os_trap(_Event ev, _Context *ctx) {
  _Context *next = NULL;
  for (auto &h: handlers_sorted_by_seq) {
    if (h.event == _EVENT_NULL || h.event == ev.event) {
      _Context *r = h.handler(ev, ctx);
      panic_on(r && next, "returning multiple contexts");
      if (r) next = r;
    }
  }
  panic_on(!next, "returning NULL context");
  panic_on(sane_context(next), "returning to invalid context");
  return next;
}</code></pre>


<div markdown="1"><div class="fenced fenced-blue"><div>
<h4 id="assertions">防御性的 Assertions</h4>
<p>注意到上述代码中一些防御性的 assertions，它们检查 specifications 是否被违反。在程序的各个地方添加防御性的 assertions 能最大程度保护你们不受伤害——例如在某个罕见的执行路径上，你忘记返回 context，或是 context 已经被损坏，你会得到 assertion failure 而不是虚拟机的神秘重启。</p>
<ul>
<li><code>sane_context</code> 如何实现？不妨可以考虑例如 <code>cs</code>, <code>rip</code>, <code>rflags</code> 等寄存器合法的值。</li>
</ul>
<p>此外，当前的 assert failure 只能打印出失败的位置。如果你写一小段代码，能够打印出 call stack frame，那会极大程度简化你们调试的过程——虽然这不是必须的。</p>
</div></div></div>

<p>借助 <code>os-&gt;on_irq</code>，我们可以 “注册” 若干中断处理程序，在适当的时机做适当的事情——这类似于 “面向切面编程” (<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspected-Oriented Programming, AOP</a>) 的设计。此时，我们的 os 模块并不需要知道系统中有多少中断、多少设备驱动程序可能会处理中断，例如，如果我们希望在 I/O 设备发生中断时，向键盘驱动的信号量执行一个 V 操作，我们只需要：</p>
<pre class="codehilite"><code class="language-c">static _Context *input_notify(_Event ev, _Context *context) {
  kmt-&gt;sem_signal(&sem_kbdirq); // 在IO设备中断到来时，执行V操作唤醒一个线程
  return NULL;
}

void input_init() {
  // seq == 100 是随意设置地，我们并不在意何时调用
  os-&gt;on_irq(100, _EVENT_IRQ_IODEV, input_notify); 
  ...
}</code></pre>


<p>甚至在 jyy 的参考实现中，寄存器现场保存、执行调度程序的代码，也都是用 <code>on_irq</code> 注册的 (尽管你并不必要这么做，可以把这部分代码直接写在 <code>os-&gt;trap</code> 中)：</p>
<pre class="codehilite"><code class="language-c">// thread.c，线程管理
static void kmt_init() {
  ...
  os-&gt;on_irq(INT_MIN, _EVENT_NULL, kmt_context_save);   // 总是最先调用
  os-&gt;on_irq(INT_MAX, _EVENT_NULL, kmt_schedule);       // 总是最后调用
  ...
}</code></pre>


<p>如果上述代码被执行，那么按照注册时的 sequence number 进行调用：</p>
<ul>
<li>在时钟中断发生时依次调用 <code>kmt_context_save</code> (<code>INT_MIN</code>) 和 <code>kmt_schedule</code> (<code>INT_MAX</code>)；</li>
<li>在键盘中断发生时依次调用 <code>kmt_context_save</code> (<code>INT_MIN</code>), <code>input_notify</code> (<code>100</code>), 和 <code>kmt_schedule</code> (<code>INT_MAX</code>)</li>
</ul>
<blockquote>
<p><span class="red"><strong>不需要实现成线程/中断安全的</strong></span>：你可以假设 <code>os-&gt;on_irq</code> 在单处理器、中断关闭下 <code>os-&gt;run</code> 被调用之前全部执行完毕。</p>
</blockquote>
<h3 id="23-pmm-physical-memory-management">2.3 PMM (Physical Memory Management) 模块</h3>
<p>pmm 与之前行为一致，但因为它被调用的场景增加了 (并不是每个 CPU 只是连续不断地执行代码，而是 CPU 可能被中断)，我们需要稍稍对它进行改进：</p>
<blockquote>
<p><span class="red"><strong>需要实现成线程/中断安全的</strong></span>：允许任意线程/中断处理程序调用 <code>pmm-&gt;alloc</code> 和 <code>pmm-&gt;free</code>。</p>
</blockquote>
<p>具体来说，我们要求:</p>
<ol>
<li>可以在中断里调用 <code>pmm-&gt;alloc()</code> 和 <code>pmm-&gt;free()</code>；</li>
<li>内存分配/回收时，简单起见，不允许被中断。</li>
</ol>
<p>可以用以下方法简单做到：</p>
<pre class="codehilite"><code class="language-c">static void *kalloc_safe(size_t size) {
  int i = _intr_read();
  _intr_write(0);
  void *ret = kalloc(size);
  if (i) _intr_write(1);
  return ret;
}

static void kfree_safe(void *ptr) {
  int i = _intr_read();
  _intr_write(0);
  kfree(ptr);
  if (i) _intr_write(1);
}</code></pre>


<p>我们不推荐你在 pmm 中使用 <code>kmt-&gt;spinlock</code>，而是保持现有的实现不变，因为你可能在 <code>kmt-&gt;init()</code> 的时候调用 <code>pmm-&gt;alloc()</code>，此时自旋锁可能还没有完成必要的初始化。</p>
<h3 id="24-kmt-kernel-multi-threading">2.4 KMT (Kernel Multi-Threading) 模块</h3>
<h4 id="241">2.4.1 模块初始化</h4>
<p><code>kmt-&gt;init()</code> 负责初始化必要的数据，例如分配一些重要的数据结构。我们预期你会在 <code>os-&gt;init()</code> 时调用 <code>kmt-&gt;init()</code>。整个系统启动只调用一次 <code>kmt-&gt;init()</code>。</p>
<h4 id="242">2.4.2 线程管理</h4>
<pre class="codehilite"><code class="language-c">int  (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);
void (*teardown)(task_t *task);</code></pre>


<p>其中 <code>create</code> 在系统中创建一个线程 (<code>task_t</code> 应当事先被分配好)，这个线程立即就可以被调度执行 (但调用 create 时中断可能处于关闭状态，在打开中断后它才获得被调度执行的权利)。我们假设 <code>create</code> 创建的线程永不返回——但它有可能在永远不会被调度执行的情况下被调用 <code>kmt-&gt;teardown</code> 回收。</p>
<p><code>teardown</code> 相应回收为线程分配的资源——例如你可能会为 <code>task_t</code> 动态分配内存：</p>
<pre class="codehilite"><code class="language-c">int kmt_create(task_t *task, const char *name, void (*entry)(void *arg), void *arg) {
  ...
  task-&gt;stack = pmm-&gt;alloc(STACK_SIZE); // 动态分配内核栈
  ...
}</code></pre>


<p>这部分的内存需要在 <code>teardown()</code> 时被回收。线程只有在永远不会被调度到处理器上执行的前提下才能被回收。你可以假设回收的时候线程不再持有任何自旋锁或在信号量上等待。</p>
<blockquote>
<p><span class="red"><strong>需要实现成线程安全的</strong></span>：允许任意线程调用 <code>create</code>/<code>teardown</code>。不会在中断处理程序中调用 <code>create</code>/<code>teardown</code>。</p>
</blockquote>
<h4 id="243">2.4.3 自旋锁</h4>
<pre class="codehilite"><code class="language-c">void (*spin_init)(spinlock_t *lk, const char *name);
void (*spin_lock)(spinlock_t *lk);
void (*spin_unlock)(spinlock_t *lk);</code></pre>


<p>lock-unlock 实现保护一段强原子性 (任何其他线程、中断处理程序、其他处理器都不能同时得到同一把锁)：</p>
<ul>
<li>允许在中断处理程序中调用自旋锁；</li>
<li>允许任意在任意处理器的任意线程中调用自旋锁；</li>
<li><code>spin_lock</code> 将会关闭处理器的中断，因此对一个处理器而言，持有任何一个自旋锁之后就不会再发生线程切换；</li>
<li><code>spin_unlock</code> 在解除最后一个当前处理器持有的自旋锁之后，需要将处理器的中断状态恢复。例如在中断处理程序中，中断是关闭的，因此 <code>spin_unlock</code> 不应该打开中断；但在一般的线程中，<code>spin_unlock</code> 后应当恢复处理器的中断。</li>
</ul>
<blockquote>
<p><span class="red"><strong>需要实现成线程/中断安全的</strong></span>：允许任意线程调用 <code>spin_init</code>, <code>spin_lock</code> 和 <code>spin_unlock</code>。中断处理程序允许调用 <code>spin_lock</code> 和 <code>spin_unlock</code>。</p>
</blockquote>
<h4 id="244">2.4.4 信号量</h4>
<pre class="codehilite"><code class="language-c">void (*sem_init)(sem_t *sem, const char *name, int value);
void (*sem_wait)(sem_t *sem);
void (*sem_signal)(sem_t *sem);</code></pre>


<p>在信号量初始化时，<code>value</code> 指定了它初始的数值。初始时 <code>value == 1</code> 可以把信号量当互斥锁；初始时 <code>value == 0</code> 可以把信号量作为生产者-消费者缓冲区管理实现。<code>sem_wait</code> 和 <code>sem_signal</code> 分别对应了 P/V 操作。</p>
<ul>
<li>允许在线程中执行信号量的 <code>sem_wait</code> 操作。在 P 操作执行没有相应资源时，线程将被阻塞 (不再被调度执行)。中断没有对应的线程、不能阻塞，因此不能在中断时调用 <code>sem_wait</code>；</li>
<li>允许在任意状态下任意执行 <code>sem_signal</code>，包括任何处理器中的任何线程和任何处理器的任何中断。</li>
</ul>
<p>在信号量实现时，大约需要做以下几件事 (任何一本操作系统教材上都会提到类似的实现)：</p>
<pre class="codehilite"><code class="language-c">void sem_wait(sem_t *sem) {
  spin_lock(&sem-&gt;lock); // 获得自旋锁
  sem-&gt;count--; // 自旋锁保证原子性
  if (...) {
    // 没有资源，需要等待
    ...
    mark_as_not_runnable(current); // 当前线程不能再执行
  }
  spin_unlock(&sem-&gt;unlock);
  if (...) {  // 如果 P 失败，不能继续执行
              // (注意此时可能有线程执行 V 操作)
    _yield(); // 引发一次上下文切换
  }
}</code></pre>


<blockquote>
<p><span class="red"><strong>需要实现成线程安全和部分中断安全的</strong></span>：多处理器安全。允许任意线程调用 <code>sem_init</code>, <code>sem_wait</code> 和 <code>sem_signal</code>。中断处理程序只允许调用 <code>sem_signal</code>。</p>
</blockquote>
<h2 id="3">3. 正确性标准</h2>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">不要打印多余的输出</h4>
<p>在任何时候 (锁、中断、……) 时打印多余的输出都可能导致 Wrong Answer。因此我们建议你使用自己的 log 或 printk 函数 (而不是 printf; 我们的测试程序会使用 printf)，且它们的行为由预编译指令控制，仅在你本地编译时才打印数据。</p>
<p>当然了，系统启动时 (<code>_mpe_init</code> 之前) 打印少量日志是没问题的。</p>
</div></div></div>

<h3 id="31-safety-liveness">3.1 Safety 和 Liveness</h3>
<p>在任意时刻，操作系统中都可能有多个线程，你需要设计调度的策略在多个处理器中调度这些线程，使系统中能够被执行的线程尽可能不发生饥饿。</p>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">一个特别的正确性要求</h4>
<p>在线程数不过多的前提 (十几) 下，我们要求每个可运行的线程，给定足够长 (例如数秒) 的时间，能够被调度到每个处理器上执行。这个需求看起来很简单：稍微改一改 <code>thread-os-mp.c</code> 的调度器就行了。但你要警惕了！这可能比你想象的困难得多。</p>
</div></div></div>

<p>经过 Lab1 的洗礼，你们应该意识到，写出正确的程序要从简单、有效的策略开始，盲目使用复杂的策略只会让你陷入 Wrong Answer 的泥潭。</p>
<h3 id="32">3.2 官方测试用例</h3>
<p>官方测试用例使你的 “操作系统” 看起来更像是个操作系统。但它并不能作为 “压力测试” 来帮助你检查 kmt 实现的正确性。我们为大家提供了 dev 模块及其实现：</p>
<pre class="codehilite"><code class="language-c">typedef struct device device_t;
MODULE(dev) {
  void (*init)();
  device_t *(*lookup)(const char *name);
};</code></pre>


<p>我们的官方测试用例还包含了以下设备的驱动 (我们将会在课程进展到一半左右的时候讲解设备在操作系统上的抽象，此时会讲解什么是设备驱动程序)：</p>
<ul>
<li><code>input</code>，支持读取键盘的输入；</li>
<li><code>fb</code>，支持一个软件模拟的 2D 显示加速器的写入 (我们打算未来把这个显示加速器用真正的硬件实现)；</li>
<li><code>tty1</code>, <code>tty2</code>, 两个支持读写的虚拟终端，使用 Alt-1, Alt-2 在虚拟中断之间切换；</li>
<li><code>sda</code>, 支持读写的物理磁盘。你可以从中读出操作系统内核的 ELF 文件。</li>
</ul>
<p>在这个实验中，你并不需要调试正确所有的设备驱动程序 (但调试不通过一般意味着 Online Judge 会测试失败)。但在下一个实验中，我们会用到这些设备驱动程序。</p>
<p>代码合并后，你需要在 <code>os-&gt;init()</code> 中手工添加设备模块的初始化 <code>dev-&gt;init()</code>。如果实现正确，就能完成中断处理程序 (和若干设备相关线程) 的初始化。你不需要添加额外的代码，就能看到闪烁的光标，并且能看到输入字符的回显。</p>
<p>此后，你就可以创建若干访问设备的线程，例如你可以为每个 tty 设备创建一个线程：</p>
<pre class="codehilite"><code class="language-c">static void tty_reader(void *arg) {
  device_t *tty = dev-&gt;lookup(arg);
  char cmd[128], resp[128], ps[16];
  snprintf(ps, 16, "(%s) $ ", arg);
  while (1) {
    tty-&gt;ops-&gt;write(tty, 0, ps, strlen(ps));
    int nread = tty-&gt;ops-&gt;read(tty, 0, cmd, sizeof(cmd) - 1);
    cmd[nread] = '\0';
    sprintf(resp, "tty reader task: got %d character(s).\n", strlen(cmd));
    tty-&gt;ops-&gt;write(tty, 0, resp, strlen(resp));
  }
}

static void os_init() {
  ...
  kmt-&gt;create(task_alloc(), "tty_reader", tty_reader, "tty1");
  kmt-&gt;create(task_alloc(), "tty_reader", tty_reader, "tty2");
}</code></pre>


<p><img alt="" class="center" src="../static/wiki/os/2020/labs/img/lab2-drv.png" width="500px"></img></p>
<div markdown="1"><div class="fenced fenced-blue"><div>
<h4 id="_1">那么好的测试用例，上哪里获取呢？</h4>
<p>哇！做完实验我好像有 “操作系统” 的感觉了！然后再看看 trivial-os.c 的代码，仿佛我看到了写出一个真正操作系统的希望。没错——你在这个实验中活下来，就意味着你已经掌握操作系统原理中最重要的部分：如何实现处理器的分时虚拟化。接下来，你只需要理解：</p>
<ol>
<li>文件系统是磁盘上的数据结构；</li>
<li>进程是拥有独立地址空间的线程，</li>
</ol>
<p>你其实就在 high-level 上对现代操作系统有了一个准确的认识 (当然还有无数细节)，这门课的目标也就达到了。获取驱动程序，请在命令行中使用</p>
<pre class="codehilite"><code>git pull origin L2-dev</code></pre>


<p>获取官方测试用例。代码合并后，因为我们对你的 <code>include/</code> 目录中的代码不做任何限制，你可能会出现一些诸如结构体未定义等问题，照常解决即可。如果发现测试用例中的 bugs，请向我们报告 (我们不完全保证测试用例的正确性😂)。</p>
</div></div></div>

<h3 id="33-online-judge">3.3 Online Judge 上的测试用例</h3>
<p>与 L1 类似，我们的测试代码会使用自己的 <code>framework</code> 代码，但我们会调用你的 <code>os-&gt;init()</code> 和 <code>os-&gt;run()</code>，就像下面的代码那样：</p>
<pre class="codehilite"><code class="language-c">static void producer(void *arg) { ... }
static void consumer(void *arg) { ... }
static void create_threads() {
  ...
  kmt-&gt;create(pmm-&gt;alloc(sizeof(task_t)),
              "test-thread-1", producer, xxx);
  kmt-&gt;create(pmm-&gt;alloc(sizeof(task_t)),
              "test-thread-2", consumer, yyy);
  ...
}
int main() {
  _ioe_init();
  _cte_init(os-&gt;trap);
  os-&gt;init();
  create_threads();
  _mpe_init(os-&gt;run); // all cores call os-&gt;run()
  return 1;
}</code></pre>


<p>我们的 producer/consumer 可能就像上课的例子那样，管理 empty 和 fill 两个信号量，分别打印左括号和右括号，然后我们会检查输出是否满足 (1) 是合法括号序列的一个前缀; (2) 括号嵌套的深度是否超过要求。与 Lab1 一样，我们在测试时会链接一个我们实现正确的 klib，所以大家即便 klib 有 bug，也不必太过担心。</p>
<h2 id="4">4. 实验指南</h2>
<h3 id="41">4.1 坐下来，读一读代码</h3>
<div markdown="1"><div class="fenced fenced-green"><div>
<h4 id="_1">不知道实验要求在说什么？</h4>
<p>拿到这个实验的第一感觉就是：实验要求也太 tmd 长了。这玩意还要 Online Judge，还不得死人了？这是很正常的。不要慌，因为你们已经有过 Lab1 的经验，现在你们可以多花一点时间来读代码了。</p>
</div></div></div>

<p>读代码可以从我们之前提到的几个例子开始：</p>
<ul>
<li><a href="../static/wiki/os/2020/demos/thread-os.c">thread-os.c</a>: 一个分时调度固定数量线程、round-robin调度的嵌入式操作系统；</li>
<li><a href="../static/wiki/os/2020/demos/thread-os-mp.c">thread-os-mp.c</a>: 把刚才的代码扩展到多处理器；</li>
<li><a href="../static/wiki/os/2020/demos/trivial-os.c">trivial-os.c</a>: 真正的多处理器多进程操作系统，不过每个进程只允许拥有一个页面。</li>
</ul>
<p>你可以仿照 amgame 或 kernel，为它们编写 Makefile，然后把它们编译运行甚至调试。在视频回看中你能找到这些代码的详细讲解。如果你试着调试一下 AbstractMachine 的代码，例如 <code>thread-os</code> 在一次时钟中断后的代码，结合 AbstractMachine 的文档，你就能对中断到底发生了什么、AbstractMachine 到底做了什么有更加深入的认识——更重要的是，<code>thread-os.c</code> 和 <code>thread-os-mp.c</code> 是大家实现 Lab2 的一个 “基础性” 的框架。不要忘记了，我们的 Lab2 就是要实现丰富版的 <code>thread-os-mp.c</code>!</p>
<p>而 <code>thread-os.c</code> 中比较重要的是，首先它注册了系统全局的中断处理函数：</p>
<pre class="codehilite"><code class="language-c">_cte_init(on_interrupt);</code></pre>


<p>而这个函数在我们的实验中的对应就是 <code>os-&gt;trap()</code>。于是你会知道 <code>os-&gt;trap</code> 的代码会和 <code>on_interrupt</code> 比较像：</p>
<pre class="codehilite"><code class="language-c">_Context *on_interrupt(_Event ev, _Context *ctx) {
  if (!current) {
    current = &tasks[0];     // first interrupt
  } else {
    current-&gt;context = ctx;  // interrupt context saved on stack
    current = current-&gt;next; // schedule the next context
  }
  return current-&gt;context;
}</code></pre>


<p>而你再去看 <code>os-&gt;trap</code> 和 <code>os-&gt;on_irq</code> 的实验要求，你就能发现我们实验的需求合情合理。</p>
<h3 id="42">4.2 操作系统上的程序</h3>
<p>现在，我们的操作系统还不支持进程、文件系统等，但的确有了完善的物理内存管理和线程管理 API。换句话说，我们实现的是一个支持线程的 “嵌入式操作系统”，它能运行在没有 MMU 的硬件上。</p>
<p>为这样的一个操作系统编写代码，就是直接在操作系统代码中静态链接一些函数，这些函数可以作为线程的入口，并且函数可以任意访问内核数据、直接以函数调用的形式调用操作系统内的 API。为了更好地理解实验要求，我们不妨给出一个课堂上 “生产者-消费者” 在我们操作系统上运行的例子。</p>
<p>首先，我们定义信号量 (kmt 实验需求部分)，并且用宏包装一下 P/V 操作 (这一步完全不必要，只是为了让我们的代码看起来和课堂上讲解得一样)：</p>
<pre class="codehilite"><code class="language-c">sem_t empty, fill;
#define P kmt-&gt;sem_wait
#define V kmt-&gt;sem_signal</code></pre>


<p>接下来，我们写出个生产者/消费者线程的代码，就跟我们课堂上展示的 <code>threads.h</code> 完全一样：</p>
<pre class="codehilite"><code class="language-c">void producer(void *arg) { while (1) { P(&empty); _putc('('); V(&fill);  } }
void consumer(void *arg) { while (1) { P(&fill);  _putc(')'); V(&empty); } }</code></pre>


<p>然后，我们在操作系统初始化 (<code>os-&gt;init</code>) 中创建若干个生产者/消费者线程，其中利用了物理内存的分配：</p>
<pre class="codehilite"><code class="language-c">static inline task_t *task_alloc() {
  return pmm-&gt;alloc(sizeof(task_t));
}

static void os_init() {
  pmm-&gt;init();
  kmt-&gt;init(); // 模块先初始化

#ifdef DEBUG_LOCAL
  kmt-&gt;sem_init(&empty, "empty", 5);  // 缓冲区大小为 5
  kmt-&gt;sem_init(&fill,  "fill",  0);
  for (int i = 0; i &lt; 4; i++) // 4 个生产者
    kmt-&gt;create(task_alloc(), "producer", producer, NULL);
  for (int i = 0; i &lt; 5; i++) // 5 个消费者
    kmt-&gt;create(task_alloc(), "consumer", consumer, NULL);
#endif
}</code></pre>


<p>注意到上面的 <code>DEBUG_LOCAL</code> 宏。你们可以把这个宏的定义加载你们的 <code>CFLAGS</code> 里，这样你们在本地调试的时候就会创建用于测试的线程，但在 Online Judge 上则不会。这个行为对大家来说很重要：你们打印任何多余的输出，都可能导致 Wrong Answer。</p>
<p>如果你的代码实现正确，在模拟器上运行 (可以使用 <code>smp=2</code>, <code>smp=4</code> 等运行启动多个处理器) 能够看到打印出正确的括号序列：总是合法括号序列的前缀，且括号嵌套的深度不超过 5。带着这样的一个具体的操作系统的小 “测试”，你能更好地理解框架代码——它其实并不复杂。</p>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">如果代码实现的正确？</h4>
<p>你们在编程的时候，一定会遇到无数诡异的 bug，跑着跑着虚拟机就挂了，而且错得非常离谱，完全不知道发生了什么。对于并发程序，更难受的是可能要运行很多次，或者在某个特定的条件下 bug 才会触发。但你都相信 (1) 机器永远是对的; (2) 未测代码永远是错的。</p>
<p>当然，我们不排除 AbstractMachine 有 bug、gcc 有 bug、qemu 有 bug，甚至是你的处理器有 bug。但最终无论是哪里的问题，只要使用正确的编程方式，你最终都能找到这个 bug，机器永远是对的。处理器的 bug 是它的一个 “feature”。</p>
</div></div></div>

<h3 id="43-bug">4.3 在 Bug 中活下来</h3>
<p>因此你实际回过头看，这个实验并不需要实现多少代码——比较紧凑的参考实现仅仅小几百行代码——不就是线程、自旋锁和信号量，加上一些零碎的代码 (中断处理的入口等) 嘛！那为什么实验要求要写那么长呢？还特别用红色字和灰色的底色标出 “线程/中断” 安全？是因为我们希望你的代码在多处理器、中断都存在的情况下保持正确。这不是一句空话，你下面会看到它实际的具体含义。或者说，你只有在做完实验以后，才会对下面这些话产生真正的理解：</p>
<ol>
<li>代码可以在多个处理器上被<strong>同时</strong>调用。因此你需要小心地保证原子性、顺序、可见性。千万小心：<code>kmt-&gt;create()</code>, <code>kmt-&gt;sem_signal()</code> 等所有函数都可能同时在多个处理器上被调用。你现在觉得这句话很可笑，你早就知道，但你调过 bug 就知道厉害了。</li>
<li>在中断处理程序中可以调用自旋锁。实际上，一个 CPU 的中断处理程序可以和另一个 CPU 访问同一个共享数据结构 (例如在中断中向链表里插入一个元素，这个链表被另一个线程读取)，因此自旋锁是保证正确性的重要手段。</li>
<li>小心数据竞争。一切共享的数据都可能会产生数据竞争——如果你没有保护好的话。有些内存访问悄悄在你意想不到的时候发生，例如对堆栈的访问——我们已经做出了提示，小心！小心！</li>
</ol>
<p>很快写着写着你就会发现自己的代码出 bug 了，有可能是并发的，有可能只是顺序的逻辑实现错了。如果出现了莫名其妙的异常、虚拟机神秘重启等情况不要惊慌，<strong>机器永远是对的</strong>，坐下来调代码吧。</p>
<h4 id="431">4.3.1 调试理论：再次复习</h4>
<p>在这两个学期的课程里，我们反复提到了调试理论——我们犯下的 bug 是 fault，它在运行时导致系统某个数值不符合预期 (specification), 这是一个 error，而只有最终虚拟机神秘卡死/重启/输出奇怪内容，我才真正证明了程序里 bug 的存在 (failure)。我建议大家再复习一下我们课程的视频，这部分对大家活下来非常重要。</p>
<p>为了让 bug (fault) 更容易被找到，我们有两个想法：</p>
<ol>
<li>fault → error, 让更多的 bug 能在运行时被触发出来。这是通过详尽的测试实现的——你们已经在 Lab1 里饱受测试不充分的折磨了；而你们要知道，Lab1 Online Judge 的测试远谈不上充分。</li>
<li>error → failure, 让运行时错误的状态能尽快地被捕获。我们的 klib 里已经提供了以下有用的机制帮助你检查：<ol>
<li><code>assert</code>, 你可以通过 assert 将程序应该满足的 specification (但代码未必体现) 写出来</li>
<li><code>panic</code>, 立即退出，通常是因为进入了某种不正常的状态</li>
<li><code>panic_on</code>, 条件成立时退出，检查不正常状态并退出</li>
</ol>
</li>
</ol>
<div markdown="1"><div class="fenced fenced-blue"><div>
<h4 id="_1">想放弃？</h4>
<p>相信大家有无数次想放弃。算了，成绩不要了。算了，抄作业吧。如果你坚持把 “独立完成” 想象成是对自己的训练，这是非常有益的：</p>
</div></div></div>

<p>在适当的地方加上 printf 和 assert 能帮助你快速定位到程序中出错的状态 (比如在中断到来时打印寄存器的现场，能快速帮你定位出现异常的位置)，缩小bug 的检查范围。</p>
<h4 id="432-log">4.3.2 更好的 log 方式</h4>
<p>相信大家都有过不停地加 <code>printf</code>, 删掉 <code>printf</code> 的调试体验吧。这感觉可不太好，找了一大圈，最后发现一开始删掉的 <code>printf</code> 打印的信息才是最有用的，不过一整天就已经过去了。</p>
<p>你可以考虑使用一些预编译选项控制 log 的开关：</p>
<pre class="codehilite"><code class="language-c">#ifdef TRACE_F
  #define TRACE_ENTRY printf("[trace] %s:entry\n", __func__)
  #define TRACE_EXIT printf("[trace] %s:exit\n", __func__)
#else
  #define TRACE_ENTRY ((void)0)
  #define TRACE_EXIT ((void)0)
#endif

void f() {
  TRACE_ENTRY;
  printf("This is f.\n");
  TRACE_EXIT;
}</code></pre>


<p>当然你也可以使用一些变量控制 log 的开关，例如设置 <code>print_registers_on_irq</code>。</p>
<h4 id="433">4.3.3 使用调试器</h4>
<p>让然，如果各种 <code>printf</code> 和 log 都没办法帮你找到问题，也许上 gdb 是个不错的主意。框架代码里<strong>故意</strong>没有提供 <code>make debug</code> 的选项，但我们已经频繁地在课上展示了如何调试，qemu 为我们提供了丰富的命令行选项：</p>
<ul>
<li><code>-gdb</code> 能启动调试模式；</li>
<li><code>-S</code> 能让虚拟机在收到调试命令前不执行执行；</li>
<li>在 gdb 中可以用 <code>target</code> 命令连接远程调试；</li>
<li>用 <code>.gdbinit</code> (或 <code>-x</code>, <code>-ex</code> 选项) 能实现脚本的预先执行。</li>
</ul>
<p>此外，printf 并不是唯一调试信息的来源。上课的同学应该还有印象，我们讲解过如何使用 qemu monitor 中的 log 来调试神秘的 CPU 重启。当你真正走投无路的时候，你会发现这些工具才是调试系统软件里最重要的设施。</p>
<div markdown="1"><div class="fenced fenced-red"><div>
<h4 id="_1">不信邪？</h4>
<p>如果只是写几十上百行的 OJ 程序，无论你习惯多么的坏，多多少少总是能调试出来的。但如果要维护更大的程序，用上<strong>正确的工具</strong>就能帮上大忙了。</p>
<p>因此，你在读完上面那些文字的时候，你心里肯定想：这么麻烦，关我 <math class="inline-math">\times</math> 事。对中枪的同学：当你实在找不到 bug 的时候，回来求 gdb 也许能帮你挽回几天的调试时间。这时候你就真正体会到<strong>基础设施的重要性</strong>了。</p>
</div></div></div>

<h3 id="434">4.3.4 保护自己不受伤害</h3>
<p>有些 bug 可能会非常难调试，这里举一个例子：栈溢出。也许已经有同学吃过苦头了：栈空间不是无限大的，而如果我们带着很大的局部变量或者递归很多层，栈就悄悄溢出了……在操作系统内核中，内核线程栈的溢出就显得更危险了，因为你可能会定义：</p>
<pre class="codehilite"><code class="language-c">struct task_t {
  int32_t id;
  ...
  uint8_t stack[STK_SZ];
};</code></pre>


<p>而栈溢出 (x86 的栈从高地址向低地址生长) 的后果就是线程的信息可能被覆盖，出现各种诡异 (难以理解) 的情况，而且有可能 bug 若隐若现，加一条 <code>printf</code> 也许就不触发了。如果想避免这种情况的发生，可以给栈的前后加一些栅栏缓冲 (fences)，或者金丝雀 (canaries)，我们上课时也讲解过。</p>
<p>同理，我们可以在 kalloc/free 的时候做一些 hacking，这样可以帮助你检查出很多类型的 bugs，例如你可以在 free 以后将内存全部填为某一个 magic number，然后在关键的 pointer deference 的地方插入</p>
<pre class="codehilite"><code class="language-c">#define uaf_check(ptr) \
  panic_on(MAGIC == *(uint32_t *)(ptr), "use-after-free");

*ptr ... // important pointer, e.g., current
uaf_check(ptr)</code></pre>


<p>这些 defensive 的编程方式，帮助你把代码中应该满足的 specification 明确地在代码中写出来——我们优先假设我们的代码是有 bug 的，而不是没有 bug 的。在此假设下，做的检查越多，越能减少 bug 对我们调试带来的痛苦。</p>
<p>最后，这几节中介绍的知识都是<strong>完全没有用</strong>的——如果你不写够大的代码，做够系统的项目，你永远都不会用到这里的知识，永远都不会想把 C 语言的能力发挥到极致。这里的知识对理论考试几乎完全没有任何帮助。但正是在种种细节上追求完美才成就了大型软件系统的成功。在阅读优雅的代码时总有赏心悦目的快乐。关于操作系统内核，xv6 绝对是一份了不起的佳作，看似平淡无奇的代码里参透着系统设计的智慧，值得大家品位。</p>
    </div>
  </div>
</center>

<div class="footer-bottom">
  <center>
    <div class="copyright"> © 2020 Yanyan Jiang, All rights reserved </div>
  </center>
</div>


    <script>
      $(function () {
        $('[data-toggle="tooltip"]').tooltip()
      })

      $("math").each(function() {
        var tex = $(this).text();
        var html = katex.renderToString(tex, {
          displayMode: $(this).attr('class') == 'block-math',
          throwOnError: false
        });
        $(this).replaceWith(html);
      });

      function get_token() {
        var match = document.cookie.match(new RegExp('(^| )token=([^;]+)'));
        if (match) return match[2];
        else return "";
      }

      var token = get_token();
      var hint = "token", box = $("#token-input");

      if (token == "") { box.val(hint); }
      else { box.val(token); }

      function login() {
        var token = box.val()
        document.cookie = 'token=' + token + '; expires=Fri, 31 Dec 9999 23:59:59 GMT;';
        if (token == '') {
          box.val(hint);
        }
      }
    </script>
  </body>
</html>